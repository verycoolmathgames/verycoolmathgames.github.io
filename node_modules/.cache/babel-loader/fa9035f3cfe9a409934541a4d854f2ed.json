{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst querystring = require(\"querystring\");\n\nconst stream = require(\"stream\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst isbrowser_1 = require(\"../isbrowser\");\n\nconst messages = require(\"../messages\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar CertificateFormat;\n\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\n\nclass OAuth2Client extends authclient_1.AuthClient {\n  constructor(optionsOrClientId, clientSecret, redirectUri) {\n    super();\n    this.certificateCache = {};\n    this.certificateExpiry = null;\n    this.certificateCacheFormat = CertificateFormat.PEM;\n    this.refreshTokenPromises = new Map();\n    const opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret,\n      redirectUri\n    };\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n\n\n  generateAuthUrl(opts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n    }\n\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  generateCodeVerifier() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n  }\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n\n\n  generateCodeVerifierAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // base64 encoding uses 6 bits per character, and we want to generate128\n      // characters. 6*128/8 = 96.\n      const crypto = crypto_1.createCrypto();\n      const randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n      // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n      // swapping out a few chars.\n\n      const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n      const unencodedCodeChallenge = yield crypto.sha256DigestBase64(codeVerifier); // We need to use base64UrlEncoding instead of standard base64\n\n      const codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n      return {\n        codeVerifier,\n        codeChallenge\n      };\n    });\n  }\n\n  getToken(codeOrOptions, callback) {\n    const options = typeof codeOrOptions === 'string' ? {\n      code: codeOrOptions\n    } : codeOrOptions;\n\n    if (callback) {\n      this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  getTokenAsync(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const values = {\n        code: options.code,\n        client_id: options.client_id || this._clientId,\n        client_secret: this._clientSecret,\n        redirect_uri: options.redirect_uri || this.redirectUri,\n        grant_type: 'authorization_code',\n        code_verifier: options.codeVerifier\n      };\n      const res = yield this.transporter.request({\n        method: 'POST',\n        url,\n        data: querystring.stringify(values),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      const tokens = res.data;\n\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n\n      this.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    });\n  }\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n\n\n  refreshToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!refreshToken) {\n        return this.refreshTokenNoCache(refreshToken);\n      } // If a request to refresh using the same token has started,\n      // return the same promise.\n\n\n      if (this.refreshTokenPromises.has(refreshToken)) {\n        return this.refreshTokenPromises.get(refreshToken);\n      }\n\n      const p = this.refreshTokenNoCache(refreshToken).then(r => {\n        this.refreshTokenPromises.delete(refreshToken);\n        return r;\n      }, e => {\n        this.refreshTokenPromises.delete(refreshToken);\n        throw e;\n      });\n      this.refreshTokenPromises.set(refreshToken, p);\n      return p;\n    });\n  }\n\n  refreshTokenNoCache(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const data = {\n        refresh_token: refreshToken,\n        client_id: this._clientId,\n        client_secret: this._clientSecret,\n        grant_type: 'refresh_token'\n      }; // request for new token\n\n      const res = yield this.transporter.request({\n        method: 'POST',\n        url,\n        data: querystring.stringify(data),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      const tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n\n      this.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    });\n  }\n\n  refreshAccessToken(callback) {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n\n    if (callback) {\n      this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  refreshAccessTokenAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = yield this.refreshToken(this.credentials.refresh_token);\n      const tokens = r.tokens;\n      tokens.refresh_token = this.credentials.refresh_token;\n      this.credentials = tokens;\n      return {\n        credentials: this.credentials,\n        res: r.res\n      };\n    });\n  }\n\n  getAccessToken(callback) {\n    if (callback) {\n      this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  getAccessTokenAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n\n      if (shouldRefresh) {\n        if (!this.credentials.refresh_token) {\n          throw new Error('No refresh token is set.');\n        }\n\n        const r = yield this.refreshAccessTokenAsync();\n\n        if (!r.credentials || r.credentials && !r.credentials.access_token) {\n          throw new Error('Could not refresh access token.');\n        }\n\n        return {\n          token: r.credentials.access_token,\n          res: r.res\n        };\n      } else {\n        return {\n          token: this.credentials.access_token\n        };\n      }\n    });\n  }\n\n  getRequestMetadata(url, callback) {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   * @param url The optional url being authorized\n   */\n\n\n  getRequestHeaders(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const res = yield this.getRequestMetadataAsync(url);\n      return res.headers;\n    });\n  }\n\n  getRequestMetadataAsync(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const thisCreds = this.credentials;\n\n      if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n        throw new Error('No access, refresh token or API key is set.');\n      }\n\n      if (thisCreds.access_token && !this.isTokenExpiring()) {\n        thisCreds.token_type = thisCreds.token_type || 'Bearer';\n        const headers = {\n          Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n        };\n        return {\n          headers\n        };\n      }\n\n      if (this.apiKey) {\n        return {\n          headers: {}\n        };\n      }\n\n      let r = null;\n      let tokens = null;\n\n      try {\n        r = yield this.refreshToken(thisCreds.refresh_token);\n        tokens = r.tokens;\n      } catch (err) {\n        const e = err;\n\n        if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n          e.message = 'Could not refresh access token.';\n        }\n\n        throw e;\n      }\n\n      const credentials = this.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      this.credentials = tokens;\n      const headers = {\n        Authorization: credentials.token_type + ' ' + tokens.access_token\n      };\n      return {\n        headers,\n        res: r.res\n      };\n    });\n  }\n  /**\n   * Generates an URL to revoke the given token.\n   * @param token The existing token to be revoked.\n   */\n\n\n  static getRevokeTokenUrl(token) {\n    const parameters = querystring.stringify({\n      token\n    });\n    return \"\".concat(OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_, \"?\").concat(parameters);\n  }\n\n  revokeToken(token, callback) {\n    const opts = {\n      url: OAuth2Client.getRevokeTokenUrl(token),\n      method: 'POST'\n    };\n\n    if (callback) {\n      this.transporter.request(opts).then(r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n  revokeCredentials(callback) {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  revokeCredentialsAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const token = this.credentials.access_token;\n      this.credentials = {};\n\n      if (token) {\n        return this.revokeToken(token);\n      } else {\n        throw new Error('No access token to revoke.');\n      }\n    });\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  requestAsync(opts, retry = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let r2;\n\n      try {\n        const r = yield this.getRequestMetadataAsync(opts.url);\n\n        if (r.headers && r.headers.Authorization) {\n          opts.headers = opts.headers || {};\n          opts.headers.Authorization = r.headers.Authorization;\n        }\n\n        if (this.apiKey) {\n          opts.params = Object.assign(opts.params || {}, {\n            key: this.apiKey\n          });\n        }\n\n        r2 = yield this.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n\n        if (res) {\n          const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - An access_token and refresh_token were available, but no\n          //   expiry_date was availabe. This can happen when developers stash\n          //   the access_token and refresh_token for later use, but the\n          //   access_token fails on the first try because it's expired.\n\n          const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && !this.credentials.expiry_date;\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n\n          if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n            yield this.refreshAccessTokenAsync();\n            return this.requestAsync(opts, true);\n          }\n        }\n\n        throw e;\n      }\n\n      return r2;\n    });\n  }\n\n  verifyIdToken(options, callback) {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  verifyIdTokenAsync(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!options.idToken) {\n        throw new Error('The verifyIdToken method requires an ID Token');\n      }\n\n      const response = yield this.getFederatedSignonCertsAsync();\n      const login = yield this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n      return login;\n    });\n  }\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n\n\n  getTokenInfo(accessToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const _ref = yield this.transporter.request({\n        method: 'GET',\n        url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n        params: {\n          access_token: accessToken\n        }\n      }),\n            data = _ref.data;\n\n      const info = Object.assign({\n        expiry_date: new Date().getTime() + data.expires_in * 1000,\n        scopes: data.scope.split(' ')\n      }, data);\n      delete info.expires_in;\n      delete info.scope;\n      return info;\n    });\n  }\n\n  getFederatedSignonCerts(callback) {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  getFederatedSignonCertsAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const nowTime = new Date().getTime();\n      const format = isbrowser_1.isBrowser() ? CertificateFormat.JWK : CertificateFormat.PEM;\n\n      if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n        return {\n          certs: this.certificateCache,\n          format\n        };\n      }\n\n      let res;\n      let url;\n\n      switch (format) {\n        case CertificateFormat.PEM:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n          break;\n\n        case CertificateFormat.JWK:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n          break;\n\n        default:\n          throw new Error(\"Unsupported certificate format \".concat(format));\n      }\n\n      try {\n        res = yield this.transporter.request({\n          url\n        });\n      } catch (e) {\n        throw new Error('Failed to retrieve verification certificates: ' + e);\n      }\n\n      const cacheControl = res ? res.headers['cache-control'] : undefined;\n      let cacheAge = -1;\n\n      if (cacheControl) {\n        const pattern = new RegExp('max-age=([0-9]*)');\n        const regexResult = pattern.exec(cacheControl);\n\n        if (regexResult && regexResult.length === 2) {\n          // Cache results with max-age (in seconds)\n          cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n        }\n      }\n\n      let certificates = {};\n\n      switch (format) {\n        case CertificateFormat.PEM:\n          certificates = res.data;\n          break;\n\n        case CertificateFormat.JWK:\n          for (const key of res.data.keys) {\n            certificates[key.kid] = key;\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unsupported certificate format \".concat(format));\n      }\n\n      const now = new Date();\n      this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n      this.certificateCache = certificates;\n      this.certificateCacheFormat = format;\n      return {\n        certs: certificates,\n        format,\n        res\n      };\n    });\n  }\n\n  verifySignedJwtWithCerts() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n  }\n  /**\n   * Verify the id token is signed with the correct certificate\n   * and is from the correct audience.\n   * @param jwt The jwt to verify (The ID Token in this case).\n   * @param certs The array of certs to test the jwt against.\n   * @param requiredAudience The audience to test the jwt against.\n   * @param issuers The allowed issuers of the jwt (Optional).\n   * @param maxExpiry The max expiry the certificate can be (Optional).\n   * @return Returns a promise resolving to LoginTicket on verification.\n   */\n\n\n  verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const crypto = crypto_1.createCrypto();\n\n      if (!maxExpiry) {\n        maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n      }\n\n      const segments = jwt.split('.');\n\n      if (segments.length !== 3) {\n        throw new Error('Wrong number of segments in token: ' + jwt);\n      }\n\n      const signed = segments[0] + '.' + segments[1];\n      const signature = segments[2];\n      let envelope;\n      let payload;\n\n      try {\n        envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n      } catch (err) {\n        throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n      }\n\n      if (!envelope) {\n        throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n      }\n\n      try {\n        payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n      } catch (err) {\n        throw new Error('Can\\'t parse token payload: ' + segments[0]);\n      }\n\n      if (!payload) {\n        throw new Error('Can\\'t parse token payload: ' + segments[1]);\n      }\n\n      if (!certs.hasOwnProperty(envelope.kid)) {\n        // If this is not present, then there's no reason to attempt verification\n        throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n      }\n\n      const cert = certs[envelope.kid];\n      const verified = yield crypto.verify(cert, signed, signature);\n\n      if (!verified) {\n        throw new Error('Invalid token signature: ' + jwt);\n      }\n\n      if (!payload.iat) {\n        throw new Error('No issue time in token: ' + JSON.stringify(payload));\n      }\n\n      if (!payload.exp) {\n        throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n      }\n\n      const iat = Number(payload.iat);\n      if (isNaN(iat)) throw new Error('iat field using invalid format');\n      const exp = Number(payload.exp);\n      if (isNaN(exp)) throw new Error('exp field using invalid format');\n      const now = new Date().getTime() / 1000;\n\n      if (exp >= now + maxExpiry) {\n        throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n      }\n\n      const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n      const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n      if (now < earliest) {\n        throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n      }\n\n      if (now > latest) {\n        throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n      }\n\n      if (issuers && issuers.indexOf(payload.iss) < 0) {\n        throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n      } // Check the audience matches if we have one\n\n\n      if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n        const aud = payload.aud;\n        let audVerified = false; // If the requiredAudience is an array, check if it contains token\n        // audience\n\n        if (requiredAudience.constructor === Array) {\n          audVerified = requiredAudience.indexOf(aud) > -1;\n        } else {\n          audVerified = aud === requiredAudience;\n        }\n\n        if (!audVerified) {\n          throw new Error('Wrong recipient, payload audience != requiredAudience');\n        }\n      }\n\n      return new loginticket_1.LoginTicket(envelope, payload);\n    });\n  }\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n\n\n  isTokenExpiring() {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Clock skew - five minutes in seconds\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\nexports.OAuth2Client = OAuth2Client;","map":null,"metadata":{},"sourceType":"script"}