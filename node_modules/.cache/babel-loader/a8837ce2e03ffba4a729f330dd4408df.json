{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/operation\n */\n\nconst pify = require(\"pify\");\n\nconst service_object_1 = require(\"./service-object\"); // tslint:disable-next-line no-any\n\n\nclass Operation extends service_object_1.ServiceObject {\n  /**\n   * An Operation object allows you to interact with APIs that take longer to\n   * process things.\n   *\n   * @constructor\n   * @alias module:common/operation\n   *\n   * @param {object} config - Configuration object.\n   * @param {module:common/service|module:common/serviceObject|module:common/grpcService|module:common/grpcServiceObject} config.parent - The parent object.\n   */\n  constructor(config) {\n    const methods = {\n      /**\n       * Checks to see if an operation exists.\n       */\n      exists: true,\n\n      /**\n       * Retrieves the operation.\n       */\n      get: true,\n\n      /**\n       * Retrieves metadata for the operation.\n       */\n      getMetadata: {\n        reqOpts: {\n          name: config.id\n        }\n      }\n    };\n    config = Object.assign({\n      baseUrl: ''\n    }, config); // tslint:disable-next-line:no-any\n\n    config.methods = config.methods || methods;\n    super(config);\n    this.completeListeners = 0;\n    this.hasActiveListeners = false;\n    this.listenForEvents_();\n  }\n  /**\n   * Wraps the `complete` and `error` events in a Promise.\n   *\n   * @return {promise}\n   */\n\n\n  promise() {\n    return new this.Promise((resolve, reject) => {\n      this.on('error', reject).on('complete', metadata => {\n        resolve([metadata]);\n      });\n    });\n  }\n  /**\n   * Begin listening for events on the operation. This method keeps track of how\n   * many \"complete\" listeners are registered and removed, making sure polling\n   * is handled automatically.\n   *\n   * As long as there is one active \"complete\" listener, the connection is open.\n   * When there are no more listeners, the polling stops.\n   *\n   * @private\n   */\n\n\n  listenForEvents_() {\n    this.on('newListener', event => {\n      if (event === 'complete') {\n        this.completeListeners++;\n\n        if (!this.hasActiveListeners) {\n          this.hasActiveListeners = true;\n          this.startPolling_();\n        }\n      }\n    });\n    this.on('removeListener', event => {\n      if (event === 'complete' && --this.completeListeners === 0) {\n        this.hasActiveListeners = false;\n      }\n    });\n  }\n  /**\n   * Poll for a status update. Returns null for an incomplete\n   * status, and metadata for a complete status.\n   *\n   * @private\n   */\n\n\n  poll_(callback) {\n    this.getMetadata((err, body) => {\n      if (err || body.error) {\n        callback(err || body.error);\n        return;\n      }\n\n      if (!body.done) {\n        callback(null);\n        return;\n      }\n\n      callback(null, body);\n    });\n  }\n  /**\n   * Poll `getMetadata` to check the operation's status. This runs a loop to\n   * ping the API on an interval.\n   *\n   * Note: This method is automatically called once a \"complete\" event handler\n   * is registered on the operation.\n   *\n   * @private\n   */\n\n\n  startPolling_() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hasActiveListeners) {\n        return;\n      }\n\n      try {\n        const metadata = yield pify(this.poll_.bind(this))();\n\n        if (!metadata) {\n          setTimeout(this.startPolling_.bind(this), 500);\n          return;\n        }\n\n        this.emit('complete', metadata);\n      } catch (err) {\n        this.emit('error', err);\n      }\n    });\n  }\n\n}\n\nexports.Operation = Operation;","map":null,"metadata":{},"sourceType":"script"}